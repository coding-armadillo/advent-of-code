{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Advent of Code","text":"<ul> <li>2022</li> <li>2021</li> </ul>"},{"location":"2021/","title":"Advent of Code 2021","text":"Day 1 Part 1Part 2 <pre><code>with open(\"day01_input.txt\", \"r\") as f:\ndata = [int(i) for i in f.read().splitlines()]\ncount = 0\nfor i in range(1, len(data)):\nif data[i] &gt; data[i - 1]:\ncount += 1\nprint(count)\n</code></pre> <pre><code>with open(\"day01_input.txt\", \"r\") as f:\ndata = [int(i) for i in f.read().splitlines()]\nthree_measurement_data = []\nfor i in range(2, len(data)):\nthree_measurement_data.append(sum(data[i - 2 : i + 1]))\ncount = 0\nfor i in range(1, len(three_measurement_data)):\nif three_measurement_data[i] &gt; three_measurement_data[i - 1]:\ncount += 1\nprint(count)\n</code></pre> Day 2 Part 1Part 2 <pre><code>with open(\"day02_input.txt\", \"r\") as f:\ndata = [cmd.split() for cmd in f.read().splitlines()]\nhorizontal_position, depth = 0, 0\nfor action, value in data:\nvalue = int(value)\nif action == \"forward\":\nhorizontal_position += value\nelif action == \"up\":\ndepth -= value\nelif action == \"down\":\ndepth += value\nprint(horizontal_position, depth)\nprint(horizontal_position * depth)\n</code></pre> <pre><code>with open(\"day02_input.txt\", \"r\") as f:\ndata = [cmd.split() for cmd in f.read().splitlines()]\nhorizontal_position, depth, aim = 0, 0, 0\nfor action, value in data:\nvalue = int(value)\nif action == \"forward\":\nhorizontal_position += value\ndepth += aim * value\nelif action == \"up\":\naim -= value\nelif action == \"down\":\naim += value\nprint(horizontal_position, depth, aim)\nprint(horizontal_position * depth)\n</code></pre> Day 3 Part 1Part 2 <pre><code>with open(\"day03_input.txt\", \"r\") as f:\ndata = f.read().splitlines()\ncols = len(data[0])\nrows = len(data)\ngamma_rate, epsilon_rate = \"\", \"\"\nfor col in range(cols):\nones = 0\nfor row in range(rows):\nif data[row][col] == \"1\":\nones += 1\nif ones &gt; rows / 2:\ngamma_rate += \"1\"\nepsilon_rate += \"0\"\nelse:\ngamma_rate += \"0\"\nepsilon_rate += \"1\"\nprint(gamma_rate, epsilon_rate)\nprint(int(gamma_rate, 2) * int(epsilon_rate, 2))\n</code></pre> <pre><code>with open(\"day03_input.txt\", \"r\") as f:\ndata = f.read().splitlines()\ncols = len(data[0])\noxygen_generator_rating, co2_scrubber_rating = \"\", \"\"\nselections = data[:]\nfor col in range(cols):\nones = 0\nfor row in selections:\nif row[col] == \"1\":\nones += 1\nif ones &gt;= len(selections) / 2:\nselections = [row for row in selections if row[col] == \"1\"]\nelse:\nselections = [row for row in selections if row[col] == \"0\"]\nif len(selections) == 1:\noxygen_generator_rating += selections[0]\nbreak\nselections = data[:]\nfor col in range(cols):\nones = 0\nfor row in selections:\nif row[col] == \"1\":\nones += 1\nif ones &lt; len(selections) / 2:\nselections = [row for row in selections if row[col] == \"1\"]\nelse:\nselections = [row for row in selections if row[col] == \"0\"]\nif len(selections) == 1:\nco2_scrubber_rating += selections[0]\nbreak\nprint(oxygen_generator_rating, co2_scrubber_rating)\nprint(int(oxygen_generator_rating, 2) * int(co2_scrubber_rating, 2))\n</code></pre> Day 4 Part 1Part 2 <pre><code>with open(\"day04_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ndraws = lines[0].split(\",\")\nlines = [line for line in lines[1:] if line]\nboards = []\nfor i in range(0, len(lines) // 5):\nboards.append([])\nfor j in range(5):\nboards[i].append(lines[i * 5 + j].split())\nmarks = {}\nfor i in range(len(boards)):\nmarks[i] = {}\nfor row in range(5):\nfor col in range(5):\nmarks[i][boards[i][row][col]] = (row, col)\nwinning_locations = []\nfor row in range(5):\nwinning_locations.append([(row, col) for col in range(5)])\nfor col in range(5):\nwinning_locations.append([(row, col) for row in range(5)])\ndef wins(locations, winning_locations=winning_locations):\nfor winning_location in winning_locations:\nif all(loc in locations for loc in winning_location):\nreturn winning_location\nreturn None\nplays = {}\nfor i in range(len(boards)):\nplays[i] = []\nnum_plays = {}\nfor i in range(len(boards)):\ncount = 0\nfor draw in draws:\ncount += 1\nif draw in marks[i]:\nplays[i].append(marks[i][draw])\nif wins(plays[i]):\nnum_plays[i] = count, len(plays[i])\nbreak\nfastest_win = min(num_plays, key=lambda x: num_plays[x][0])\nprint(fastest_win)\nsum_unmarked = 0\nfor row in range(5):\nfor col in range(5):\nif (row, col) not in plays[fastest_win]:\nsum_unmarked += int(boards[fastest_win][row][col])\nrow, col = plays[fastest_win][-1]\nnum_call = int(boards[fastest_win][row][col])\nprint(sum_unmarked, num_call)\nprint(sum_unmarked * num_call)\n</code></pre> <pre><code>with open(\"day04_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ndraws = lines[0].split(\",\")\nlines = [line for line in lines[1:] if line]\nboards = []\nfor i in range(0, len(lines) // 5):\nboards.append([])\nfor j in range(5):\nboards[i].append(lines[i * 5 + j].split())\nmarks = {}\nfor i in range(len(boards)):\nmarks[i] = {}\nfor row in range(5):\nfor col in range(5):\nmarks[i][boards[i][row][col]] = (row, col)\nwinning_locations = []\nfor row in range(5):\nwinning_locations.append([(row, col) for col in range(5)])\nfor col in range(5):\nwinning_locations.append([(row, col) for row in range(5)])\ndef wins(locations, winning_locations=winning_locations):\nfor winning_location in winning_locations:\nif all(loc in locations for loc in winning_location):\nreturn winning_location\nreturn None\nplays = {}\nfor i in range(len(boards)):\nplays[i] = []\nnum_plays = {}\nfor i in range(len(boards)):\ncount = 0\nfor draw in draws:\ncount += 1\nif draw in marks[i]:\nplays[i].append(marks[i][draw])\nif wins(plays[i]):\nnum_plays[i] = count, len(plays[i])\nbreak\nlast_win = max(num_plays, key=lambda x: num_plays[x][0])\nprint(last_win)\nsum_unmarked = 0\nfor row in range(5):\nfor col in range(5):\nif (row, col) not in plays[last_win]:\nsum_unmarked += int(boards[last_win][row][col])\nrow, col = plays[last_win][-1]\nnum_call = int(boards[last_win][row][col])\nprint(sum_unmarked, num_call)\nprint(sum_unmarked * num_call)\n</code></pre> Day 5 Part 1Part 2 <pre><code>with open(\"day05_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\nlines = [line.split(\" -&gt; \") for line in lines]\nlines = [(tuple(line[0].split(\",\")), tuple(line[1].split(\",\"))) for line in lines]\nprint(len(lines))\nlines = [\n((int(coord1[0]), int(coord1[1])), (int(coord2[0]), int(coord2[1])))\nfor coord1, coord2 in lines\nif coord1[0] == coord2[0] or coord1[1] == coord2[1]\n]\nprint(len(lines))\nfrom collections import Counter\ndiagram = Counter()\nfor coord1, coord2 in lines:\nif coord1[0] == coord2[0]:\nfor i in range(min(coord1[1], coord2[1]), max(coord1[1], coord2[1]) + 1):\ndiagram[(coord1[0], i)] += 1\nelif coord1[1] == coord2[1]:\nfor i in range(min(coord1[0], coord2[0]), max(coord1[0], coord2[0]) + 1):\ndiagram[(i, coord1[1])] += 1\nprint(len([i for i in diagram.values() if i &gt; 1]))\n</code></pre> <pre><code>with open(\"day05_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\nlines = [line.split(\" -&gt; \") for line in lines]\nlines = [(tuple(line[0].split(\",\")), tuple(line[1].split(\",\"))) for line in lines]\nprint(len(lines))\nlines = [\n((int(coord1[0]), int(coord1[1])), (int(coord2[0]), int(coord2[1])))\nfor coord1, coord2 in lines\n]\nfrom collections import Counter\ndiagram = Counter()\nfor coord1, coord2 in lines:\nif coord1[0] == coord2[0]:\nfor i in range(min(coord1[1], coord2[1]), max(coord1[1], coord2[1]) + 1):\ndiagram[(coord1[0], i)] += 1\nelif coord1[1] == coord2[1]:\nfor i in range(min(coord1[0], coord2[0]), max(coord1[0], coord2[0]) + 1):\ndiagram[(i, coord1[1])] += 1\nelse:\nstep_x = -1 if coord1[0] - coord2[0] &gt; 0 else 1\nstep_y = -1 if coord1[1] - coord2[1] &gt; 0 else 1\nfor x, y in zip(\nrange(coord1[0], coord2[0] + (1 if step_x &gt; 0 else -1), step_x),\nrange(coord1[1], coord2[1] + (1 if step_y &gt; 0 else -1), step_y),\n):\ndiagram[(x, y)] += 1\nprint(len([i for i in diagram.values() if i &gt; 1]))\n</code></pre> Day 6 Part 1Part 2 <pre><code>with open(\"day06_input.txt\", \"r\") as f:\nfish = [int(i) for i in f.read().strip().split(\",\")]\nprint(f\"Initial state: {fish}\")\nfor _ in range(80):\nnew_fish = []\nfor i in range(len(fish)):\nfish[i] -= 1\nif fish[i] &lt; 0:\nfish[i] = 6\nnew_fish.append(8)\nfish.extend(new_fish)\nprint(f\"After {str(_+1):2s} day{'s' if _ else ''}: {fish}\")\nprint(len(fish))\n</code></pre> <pre><code>with open(\"day06_input.txt\", \"r\") as f:\nfish = [int(i) for i in f.read().strip().split(\",\")]\nfrom collections import Counter\nfish = Counter(fish)\nprint(fish)\nfor _ in range(256):\nfor i in range(-1, 9):\nif i == 8:\nfish[i] = fish[-1]\nelif i != 6:\nfish[i] = fish[i + 1]\nelse:\nfish[i] = fish[-1] + fish[i + 1]\nprint(sum([v for k, v in fish.items() if k &gt;= 0]))\n</code></pre> Day 7 Part 1Part 2 <pre><code>with open(\"day07_input.txt\", \"r\") as f:\ncrabs = [int(i) for i in f.read().strip().split(\",\")]\nprint(len(crabs))\nfrom collections import Counter\ncrabs = Counter(crabs)\noutcome = {}\nfor key in crabs:\nresult = 0\nfor key2 in crabs:\nresult += abs(key2 - key) * crabs[key2]\noutcome[key] = result\nmin_key = min(outcome, key=outcome.get)\nprint(min_key)\nprint(outcome[min_key])\n</code></pre> <pre><code>with open(\"day07_input.txt\", \"r\") as f:\ncrabs = [int(i) for i in f.read().strip().split(\",\")]\nprint(len(crabs))\nfrom collections import Counter\ncrabs = Counter(crabs)\noutcome = {}\nfor key in range(0, max(crabs.keys()) + 1):\nresult = 0\nfor key2 in crabs:\nresult += sum(range(1, abs(key2 - key) + 1)) * crabs[key2]\noutcome[key] = result\nmin_key = min(outcome, key=outcome.get)\nprint(min_key)\nprint(outcome[min_key])\n</code></pre> Day 8 Part 1Part 2 <pre><code>with open(\"day08_input.txt\", \"r\") as f:\nobs = [line.split(\" | \") for line in f.read().splitlines()]\ncount = 0\nfor o in obs:\noutput_values = o[1].split()\nfor output_value in output_values:\nif len(output_value) in [2, 3, 4, 7]:\ncount += 1\nprint(count)\n</code></pre> <pre><code>with open(\"day08_input.txt\", \"r\") as f:\nobs = [line.split(\" | \") for line in f.read().splitlines()]\ndef _sorted(digit):\nreturn \"\".join(sorted(digit))\ndef solve(digits):\nmapping = {}\nfive_segs = []\nsix_segs = []\ncf, bcdf, acf, abcdefg = None, None, None, None\nfor digit in digits:\nif len(digit) == 2:\nmapping[_sorted(digit)] = \"1\"\ncf = digit\nelif len(digit) == 3:\nmapping[_sorted(digit)] = \"7\"\nacf = digit\nelif len(digit) == 4:\nmapping[_sorted(digit)] = \"4\"\nbcdf = digit\nelif len(digit) == 7:\nmapping[_sorted(digit)] = \"8\"\nabcdefg = digit\nelif len(digit) == 5:\nfive_segs.append(digit)\nelif len(digit) == 6:\nsix_segs.append(digit)\nbd = set(bcdf) - set(cf)\neg = set(abcdefg) - (set(cf) | set(bcdf) | set(acf))\nfor digit in six_segs:\n_digit = set(digit)\nif _digit &gt;= bd and _digit &gt;= eg:\nmapping[_sorted(digit)] = \"6\"\nelif _digit &gt;= bd:\nmapping[_sorted(digit)] = \"9\"\nelif _digit &gt;= eg:\nmapping[_sorted(digit)] = \"0\"\nfor digit in five_segs:\n_digit = set(digit)\nif _digit &gt;= bd:\nmapping[_sorted(digit)] = \"5\"\nelif _digit &gt;= eg:\nmapping[_sorted(digit)] = \"2\"\nelse:\nmapping[_sorted(digit)] = \"3\"\nreturn mapping\ncount = 0\nfor o in obs:\noutput_values = o[1].split()\ndigits = o[0].split()\nmapping = solve(digits)\nvalue = \"\"\nfor digit in output_values:\nvalue += mapping[_sorted(digit)]\ncount += int(value)\nprint(count)\n</code></pre> Day 9 Part 1Part 2 <pre><code>with open(\"day09_input.txt\", \"r\") as f:\nobs = [[int(i) for i in line] for line in f.read().splitlines()]\nlow_points = []\nfor i in range(0, len(obs)):\nfor j in range(0, len(obs[i])):\nto_compare = []\nif i &gt; 0:\nto_compare.append(obs[i - 1][j])\nif i &lt; len(obs) - 1:\nto_compare.append(obs[i + 1][j])\nif j &gt; 0:\nto_compare.append(obs[i][j - 1])\nif j &lt; len(obs[i]) - 1:\nto_compare.append(obs[i][j + 1])\nif all(obs[i][j] &lt; x for x in to_compare):\nlow_points.append(obs[i][j])\nprint(sum(low_points) + len(low_points))\n</code></pre> <pre><code>with open(\"day09_input.txt\", \"r\") as f:\nobs = [[int(i) for i in line] for line in f.read().splitlines()]\nlow_points = []\nfor i in range(0, len(obs)):\nfor j in range(0, len(obs[i])):\nto_compare = []\nif i &gt; 0:\nto_compare.append(obs[i - 1][j])\nif i &lt; len(obs) - 1:\nto_compare.append(obs[i + 1][j])\nif j &gt; 0:\nto_compare.append(obs[i][j - 1])\nif j &lt; len(obs[i]) - 1:\nto_compare.append(obs[i][j + 1])\nif all(obs[i][j] &lt; x for x in to_compare):\nlow_points.append((i, j))\nbasin_sizes = []\ndef find_basin(i, j, points):\npoints.append((i, j))\nup = i\nwhile True:\nif up &gt; 0:\nif obs[up - 1][j] &gt; obs[up][j] and obs[up - 1][j] &lt; 9:\nfind_basin(up - 1, j, points)\nup -= 1\nelse:\nbreak\nelse:\nbreak\ndown = i\nwhile True:\nif down &lt; len(obs) - 1:\nif obs[down + 1][j] &gt; obs[down][j] and obs[down + 1][j] &lt; 9:\nfind_basin(down + 1, j, points)\ndown += 1\nelse:\nbreak\nelse:\nbreak\nleft = j\nwhile True:\nif left &gt; 0:\nif obs[i][left - 1] &gt; obs[i][left] and obs[i][left - 1] &lt; 9:\nfind_basin(i, left - 1, points)\nleft -= 1\nelse:\nbreak\nelse:\nbreak\nright = j\nwhile True:\nif right &lt; len(obs[i]) - 1:\nif obs[i][right + 1] &gt; obs[i][right] and obs[i][right + 1] &lt; 9:\nfind_basin(i, right + 1, points)\nright += 1\nelse:\nbreak\nelse:\nbreak\nfor i, j in low_points:\npoints = []\nfind_basin(i, j, points)\nbasin_sizes.append(len(set(points)))\nimport functools\nprint(functools.reduce(lambda x, y: x * y, sorted(basin_sizes)[-3:]))\n</code></pre> Day 10 Part 1Part 2 <pre><code>with open(\"day10_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\nmapping = {\n\")\": 3,\n\"]\": 57,\n\"}\": 1197,\n\"&gt;\": 25137,\n}\nmatch = {\n\")\": \"(\",\n\"]\": \"[\",\n\"}\": \"{\",\n\"&gt;\": \"&lt;\",\n}\ndef check(line):\nstack = []\nfor c in line:\nif c in match.values():\nstack.append(c)\nelif c in match.keys():\nif len(stack) == 0:\nreturn mapping[c]\nlast = stack.pop()\nif last != match[c]:\nreturn mapping[c]\nreturn 0\nprint(sum(check(line) for line in lines))\n</code></pre> <pre><code>with open(\"day10_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\nmapping = {\n\"(\": 1,\n\"[\": 2,\n\"{\": 3,\n\"&lt;\": 4,\n}\nmatch = {\n\")\": \"(\",\n\"]\": \"[\",\n\"}\": \"{\",\n\"&gt;\": \"&lt;\",\n}\ndef check(line):\nstack = []\nfor c in line:\nif c in match.values():\nstack.append(c)\nelif c in match.keys():\nif len(stack) == 0:\nreturn 0\nlast = stack.pop()\nif last != match[c]:\nreturn 0\nif len(stack) == 0:\nreturn 0\nscore = 0\nwhile len(stack) &gt; 0:\nlast = stack.pop()\nscore *= 5\nscore += mapping[last]\nreturn score\nscores = [check(line) for line in lines]\nscores = [s for s in scores if s &gt; 0]\nprint(len(scores))\nprint(sorted(scores)[len(scores) // 2])\n</code></pre> Day 11 Part 1Part 2 <pre><code>with open(\"day11_input.txt\", \"r\") as f:\nobs = [[int(i) for i in line] for line in f.read().splitlines()]\ndef increase(obs):\nfor i in range(len(obs)):\nfor j in range(len(obs[i])):\nobs[i][j] += 1\ndef has_flash(obs):\nlocations = []\nfor i in range(len(obs)):\nfor j in range(len(obs[i])):\nif obs[i][j] &gt; 9:\nlocations.append((i, j))\nreturn locations\ndef display(obs):\nfor i in range(len(obs)):\nprint(\"\".join([str(i) for i in obs[i]]))\nfrom collections import Counter\nprint(\"Before any steps:\")\ndisplay(obs)\nprint()\ncount = 0\nfor s in range(100):\nincrease(obs)\nflashes = set()\nwhile True:\nlocations = has_flash(obs)\nflashes.update(locations)\nif locations:\nc = Counter()\nfor i, j in locations:\nobs[i][j] = 0\nif i &gt; 0:\nc[(i - 1, j)] += 1\nif j &gt; 0:\nc[(i - 1, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i - 1, j + 1)] += 1\nif i &lt; len(obs) - 1:\nc[(i + 1, j)] += 1\nif j &gt; 0:\nc[(i + 1, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i + 1, j + 1)] += 1\nif j &gt; 0:\nc[(i, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i, j + 1)] += 1\nfor i, j in c:\nif (i, j) not in flashes:\nobs[i][j] += c[(i, j)]\nif c:\ncontinue\nbreak\nprint(f\"After step {s+1}:\")\ndisplay(obs)\nprint(f\"Flashes: {len(flashes)}\")\nprint()\ncount += len(flashes)\nprint(f\"Total flashes: {count}\")\n</code></pre> <pre><code>with open(\"day11_input.txt\", \"r\") as f:\nobs = [[int(i) for i in line] for line in f.read().splitlines()]\ndef increase(obs):\nfor i in range(len(obs)):\nfor j in range(len(obs[i])):\nobs[i][j] += 1\ndef has_flash(obs):\nlocations = []\nfor i in range(len(obs)):\nfor j in range(len(obs[i])):\nif obs[i][j] &gt; 9:\nlocations.append((i, j))\nreturn locations\ndef display(obs):\nfor i in range(len(obs)):\nprint(\"\".join([str(i) for i in obs[i]]))\nfrom collections import Counter\nprint(\"Before any steps:\")\ndisplay(obs)\nprint()\ncount = 0\noctopuses = sum([len(obs[i]) for i in range(len(obs))])\nwhile True:\nincrease(obs)\nflashes = set()\nwhile True:\nlocations = has_flash(obs)\nflashes.update(locations)\nif locations:\nc = Counter()\nfor i, j in locations:\nobs[i][j] = 0\nif i &gt; 0:\nc[(i - 1, j)] += 1\nif j &gt; 0:\nc[(i - 1, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i - 1, j + 1)] += 1\nif i &lt; len(obs) - 1:\nc[(i + 1, j)] += 1\nif j &gt; 0:\nc[(i + 1, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i + 1, j + 1)] += 1\nif j &gt; 0:\nc[(i, j - 1)] += 1\nif j &lt; len(obs[i]) - 1:\nc[(i, j + 1)] += 1\nfor i, j in c:\nif (i, j) not in flashes:\nobs[i][j] += c[(i, j)]\nif c:\ncontinue\nbreak\nprint(f\"After step {count+1}:\")\ndisplay(obs)\nprint(f\"Flashes: {len(flashes)}\")\nprint()\ncount += 1\nif len(flashes) == octopuses:\nbreak\nprint(f\"Total steps: {count}\")\n</code></pre> Day 12 Part 1Part 2 <pre><code>with open(\"day12_input.txt\", \"r\") as f:\nsegs = f.read().splitlines()\ngraph = {}\nfor seg in segs:\nnode1, node2 = seg.split(\"-\")\nif node1 not in graph:\ngraph[node1] = [node2]\nelse:\ngraph[node1].append(node2)\nif node2 not in graph:\ngraph[node2] = [node1]\nelse:\ngraph[node2].append(node1)\nfrom pprint import pprint\npprint(graph)\npaths = []\ndef breadth_first_search(graph, start, end, path=[]):\npath = path + [start]\nif start == end:\npaths.append(path)\nif start not in graph:\nreturn None\nfor node in graph[start]:\nif node not in path or node.isupper():\nnewpath = breadth_first_search(graph, node, end, path)\nif newpath:\npaths.append(newpath)\nreturn None\nbreadth_first_search(graph, \"start\", \"end\")\nfor path in paths:\nprint(\",\".join(path))\nprint(len(paths))\n</code></pre> <pre><code>with open(\"day12_input.txt\", \"r\") as f:\nsegs = f.read().splitlines()\ngraph = {}\nfor seg in segs:\nnode1, node2 = seg.split(\"-\")\nif node1 not in graph:\ngraph[node1] = [node2]\nelse:\ngraph[node1].append(node2)\nif node2 not in graph:\ngraph[node2] = [node1]\nelse:\ngraph[node2].append(node1)\nfrom pprint import pprint\npprint(graph)\npaths = []\ndef remaining(path, node):\nothers = [\nn for n in path if n != node and n.islower() and n not in [\"start\", \"end\"]\n]\nreturn all(path.count(n) &lt;= 1 for n in others)\ndef breadth_first_search(graph, start, end, path=[]):\npath = path + [start]\nif start == end:\npaths.append(path)\nif start not in graph:\nreturn None\nfor node in graph[start]:\nif (\nnode not in path\nor node.isupper()\nor (\nnode not in [\"start\", \"end\"]\nand node.islower()\nand path.count(node) &lt; 2\nand remaining(path, node)\n)\n):\nnewpath = breadth_first_search(graph, node, end, path)\nif newpath:\npaths.append(newpath)\nreturn None\nbreadth_first_search(graph, \"start\", \"end\")\nfor path in paths:\nprint(\",\".join(path))\nprint(len(paths))\n</code></pre> Day 13 Part 1Part 2 <pre><code>with open(\"day13_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ndots = []\nactions = []\nfor line in lines:\nif not line:\ncontinue\nif \",\" in line:\nx, y = line.split(\",\")\ndots.append((int(x), int(y)))\nelse:\nactions.append(line.split()[-1].split(\"=\"))\nprevious = dots[:]\nfor axis, value in actions:\nresult = []\nvalue = int(value)\nif axis == \"x\":\nfor dot in previous:\nif dot[0] &lt; value:\nresult.append((dot[0], dot[1]))\nelse:\nresult.append((2 * value - dot[0], dot[1]))\nelif axis == \"y\":\nfor dot in previous:\nif dot[1] &lt; value:\nresult.append((dot[0], dot[1]))\nelse:\nresult.append((dot[0], 2 * value - dot[1]))\nprint(len(set(result)))\nprevious = result[:]\n</code></pre> <pre><code>with open(\"day13_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ndots = []\nactions = []\nfor line in lines:\nif not line:\ncontinue\nif \",\" in line:\nx, y = line.split(\",\")\ndots.append((int(x), int(y)))\nelse:\nactions.append(line.split()[-1].split(\"=\"))\nprevious = dots[:]\nfor axis, value in actions:\nresult = []\nvalue = int(value)\nif axis == \"x\":\nfor dot in previous:\nif dot[0] &lt; value:\nresult.append((dot[0], dot[1]))\nelse:\nresult.append((2 * value - dot[0], dot[1]))\nelif axis == \"y\":\nfor dot in previous:\nif dot[1] &lt; value:\nresult.append((dot[0], dot[1]))\nelse:\nresult.append((dot[0], 2 * value - dot[1]))\nprint(len(set(result)))\nprevious = result[:]\nmax_x = max(result, key=lambda x: x[0])[0]\nmax_y = max(result, key=lambda x: x[1])[1]\nprint(max_x, max_y)\nfor y in range(max_y + 1):\nfor x in range(max_x + 1):\nif (x, y) in result:\nprint(\"#\", end=\"\")\nelse:\nprint(\" \", end=\"\")\nprint()\nfrom PIL import Image\nimg = Image.new(\"RGB\", (max_x + 1, max_y + 1), \"black\")\npixels = img.load()\nfor dot in set(result):\npixels[dot[0], dot[1]] = (255, 255, 255)\nimg.show()\n</code></pre> Day 14 Part 1Part 2 <pre><code>with open(\"day14_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ntemplate = None\npairs = []\nfor line in lines:\nif not line:\ncontinue\nif \" -&gt; \" in line:\npairs.append(line.split(\" -&gt; \"))\nelse:\ntemplate = line\nprint(f\"Template: {template}\")\nfor i in range(10):\nsegs = [template[j : j + 2] for j in range(0, len(template) - 1)]\nfor k in range(len(segs)):\nfor pair in pairs:\nif segs[k] == pair[0]:\nsegs[k] = pair[0][0] + pair[1] + pair[0][1]\ntemplate = segs[0]\nfor seg in segs[1:]:\ntemplate += seg[-2:]\nprint(f\"After step {i+1}: {template}\")\nfrom collections import Counter\ncounts = Counter(template).most_common()\nprint(counts[0][1] - counts[-1][1])\n</code></pre> <pre><code>with open(\"day14_input.txt\", \"r\") as f:\nlines = f.read().splitlines()\ntemplate = None\npairs = []\nfor line in lines:\nif not line:\ncontinue\nif \" -&gt; \" in line:\npairs.append(line.split(\" -&gt; \"))\nelse:\ntemplate = line\nprint(f\"Template: {template}\")\nsegs = [template[j : j + 2] for j in range(0, len(template) - 1)]\nfrom collections import Counter\ncounts = Counter(segs)\nfor i in range(40):\nresult = Counter()\nfor key in counts:\nfor pair in pairs:\nif key == pair[0]:\nresult[key[0] + pair[1]] += counts[key]\nresult[pair[1] + key[1]] += counts[pair[0]]\ncounts = result\nchars = Counter()\nchars[template[0]] += 1\nfor key, value in counts.items():\nchars[key[1]] += value\nchars = chars.most_common()\nprint(chars)\nprint(chars[0][1] - chars[-1][1])\n</code></pre> Day 15 Part 1Part 2 <pre><code>with open(\"day15_input.txt\", \"r\") as f:\nrisks = [[int(d) for d in line] for line in f.read().splitlines()]\nrows, cols = len(risks), len(risks[0])\n# reference: https://stackabuse.com/dijkstras-algorithm-in-python/\nfrom queue import PriorityQueue\nclass Graph:\ndef __init__(self, num_of_vertices):\nself.v = num_of_vertices\nself.edges = [\n[-1 for i in range(num_of_vertices)] for j in range(num_of_vertices)\n]\nself.visited = []\ndef add_edge(self, u, v, weight):\nself.edges[u][v] = weight\ndef dijkstra(graph, start_vertex):\nD = {v: float(\"inf\") for v in range(graph.v)}\nD[start_vertex] = 0\npq = PriorityQueue()\npq.put((0, start_vertex))\nwhile not pq.empty():\n(dist, current_vertex) = pq.get()\ngraph.visited.append(current_vertex)\nfor neighbor in range(graph.v):\nif graph.edges[current_vertex][neighbor] != -1:\ndistance = graph.edges[current_vertex][neighbor]\nif neighbor not in graph.visited:\nold_cost = D[neighbor]\nnew_cost = D[current_vertex] + distance\nif new_cost &lt; old_cost:\npq.put((new_cost, neighbor))\nD[neighbor] = new_cost\nreturn D\ng = Graph(rows * cols)\nfor i in range(rows):\nfor j in range(cols):\nif i &lt; rows - 1:\ng.add_edge((i + 1) * cols + j, i * cols + j, risks[i][j])\ng.add_edge(i * cols + j, (i + 1) * cols + j, risks[i + 1][j])\nif j &lt; cols - 1:\ng.add_edge(i * cols + j + 1, i * cols + j, risks[i][j])\ng.add_edge(i * cols + j, i * cols + j + 1, risks[i][j + 1])\nD = dijkstra(g, 0)\nprint(f\"Cost of shortest path is {D[rows*cols-1]}\")\n</code></pre> <pre><code>with open(\"day15_input.txt\", \"r\") as f:\nlines = [[int(d) for d in line] for line in f.read().splitlines()]\nrows, cols = len(lines), len(lines[0])\nlines_5x = [[0] * cols * 5 for i in range(rows * 5)]\nfor ii in range(5):\nfor jj in range(5):\nfor i in range(rows):\nfor j in range(cols):\nlines_5x[ii * rows + i][jj * cols + j] = (\nlines[i][j] + ii + jj - 1\n) % 9 + 1\n# Using the networkx library instead\nimport networkx as nx\ng = nx.DiGraph()\nrows *= 5\ncols *= 5\nfor i in range(rows):\nfor j in range(cols):\nif i &lt; rows - 1:\ng.add_edge((i, j), (i + 1, j), weight=lines_5x[i + 1][j])\ng.add_edge((i + 1, j), (i, j), weight=lines_5x[i][j])\nif j &lt; cols - 1:\ng.add_edge((i, j), (i, j + 1), weight=lines_5x[i][j + 1])\ng.add_edge((i, j + 1), (i, j), weight=lines_5x[i][j])\npaths = nx.shortest_path(\ng,\nsource=(0, 0),\ntarget=(rows - 1, cols - 1),\nweight=\"weight\",\n)\n# print(paths)\ncost = 0\nfor i, j in paths[1:]:\ncost += lines_5x[i][j]\nprint(f\"Cost of shortest path is {cost}\")\n</code></pre>"},{"location":"2022/","title":"Advent of Code 2022","text":"Day 1 Part 1Part 2 <pre><code>max_calories = 0\ncalories = 0\nwith open(\"day01_input.txt\") as f:\nfor line in f:\nif not line.strip():\nif calories &gt; max_calories:\nmax_calories = calories\ncalories = 0\ncontinue\ncalories += int(line)\nprint(max_calories)\n</code></pre> <pre><code>all_calories = []\ncalories = 0\nwith open(\"day01_input.txt\") as f:\nfor line in f:\nif not line.strip():\nall_calories.append(calories)\ncalories = 0\ncontinue\ncalories += int(line)\nprint(sum(sorted(all_calories)[-3:]))\n</code></pre> Day 2 Part 1Part 2 <pre><code>score = 0\nop_order = [\"A\", \"B\", \"C\"]\nme_order = [\"X\", \"Y\", \"Z\"]\nwith open(\"day02_input.txt\") as f:\nfor line in f:\nop, me = line.strip().split()\nind_op = op_order.index(op)\nind_me = me_order.index(me)\nif ind_me == ind_op:\nscore += ind_me + 1 + 3\nelif any(\n[\nind_me == 1 and ind_op == 0,\nind_me == 2 and ind_op == 1,\nind_me == 0 and ind_op == 2,\n]\n):\nscore += ind_me + 1 + 6\nelse:\nscore += ind_me + 1 + 0\nprint(score)\n</code></pre> <pre><code>score = 0\nop_order = [\"A\", \"B\", \"C\"]\nme_order = [\"X\", \"Y\", \"Z\"]\nwith open(\"day02_input.txt\") as f:\nfor line in f:\nop, me = line.strip().split()\nind_op = op_order.index(op)\nind_me = me_order.index(me)\nif ind_me == 1:\nscore += ind_op + 1 + 3\nelif ind_me == 2:\nshape_map = {\n0: 1 + 1,\n1: 2 + 1,\n2: 0 + 1,\n}\nscore += shape_map[ind_op] + 6\nelse:\nshape_map = {\n0: 2 + 1,\n1: 0 + 1,\n2: 1 + 1,\n}\nscore += shape_map[ind_op] + 0\nprint(score)\n</code></pre> Day 3 Part 1Part 2 <pre><code>priorities = 0\nwith open(\"day03_input.txt\") as f:\nfor line in f:\nline = line.strip()\nif not line:\ncontinue\nfirst, second = line[: len(line) // 2], line[len(line) // 2 :]\noverlap = set(first).intersection(set(second)).pop()\nif overlap.isupper():\npriorities += ord(overlap) - ord(\"A\") + 27\nelse:\npriorities += ord(overlap) - ord(\"a\") + 1\nprint(priorities)\n</code></pre> <pre><code>priorities = 0\nwith open(\"day03_input.txt\") as f:\ngroups = f.readlines()\ngroups = [groups[3 * i : 3 * i + 3] for i in range(0, len(groups) // 3)]\nfor g in groups:\nitems = None\nfor line in g:\nline = line.strip()\nif not items:\nitems = set(line)\nelse:\nitems = items.intersection(set(line))\noverlap = items.pop()\nif overlap.isupper():\npriorities += ord(overlap) - ord(\"A\") + 27\nelse:\npriorities += ord(overlap) - ord(\"a\") + 1\nprint(priorities)\n</code></pre> Day 4 Part 1Part 2 <pre><code>count = 0\nwith open(\"day04_input.txt\") as f:\nsections = f.readlines()\nfor section in sections:\nsection = section.strip()\nr1, r2 = section.split(\",\")\nr1_start, r1_stop = int(r1.split(\"-\")[0]), int(r1.split(\"-\")[1]) + 1\nr1 = set(range(r1_start, r1_stop))\nr2_start, r2_stop = int(r2.split(\"-\")[0]), int(r2.split(\"-\")[1]) + 1\nr2 = set(range(r2_start, r2_stop))\nif r1.issuperset(r2) or r2.issuperset(r1):\ncount += 1\nprint(count)\n</code></pre> <pre><code>count = 0\nwith open(\"day04_input.txt\") as f:\nsections = f.readlines()\nfor section in sections:\nsection = section.strip()\nr1, r2 = section.split(\",\")\nr1_start, r1_stop = int(r1.split(\"-\")[0]), int(r1.split(\"-\")[1]) + 1\nr1 = set(range(r1_start, r1_stop))\nr2_start, r2_stop = int(r2.split(\"-\")[0]), int(r2.split(\"-\")[1]) + 1\nr2 = set(range(r2_start, r2_stop))\nif r1.intersection(r2):\ncount += 1\nprint(count)\n</code></pre>"}]}